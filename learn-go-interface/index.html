<!doctype html><html class=no-js lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>接口-学习Go语言 - 神秘极客</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class=container><div class=logo><a class=logo__link href=/ title=神秘极客 rel=home><div class=logo__title>神秘极客</div><div class=logo__tagline>学习编程之美</div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/archives/><i class="fa fa-road"></i><span class=menu__text>学编程</span></a></li><li class=menu__item><a class=menu__link href=/about/><i class="fa fa-heart"></i><span class=menu__text>关于我</span></a></li><li class=menu__item><a class=menu__link href=/donate/><i class="fa fa-heart"></i><span class=menu__text>捐赠</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>接口-学习Go语言</h1></header><div class="post__toc toc"><div class=toc__title>目录</div><div class=toc__menu><nav id=TableOfContents><ul><li><ul><li><a href=#阅读笔记>阅读笔记</a></li><li><a href=#interface-values-with-nilgo>interface-values-with-nil.go</a></li><li><a href=#参考链接>参考链接</a></li></ul></li></ul></nav></div></div><div class="content post__content clearfix"><h3 id=阅读笔记>阅读笔记</h3><h4 id=interfacesgo>interfaces.go</h4><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Abser interface {
    Abs() float64
}

func main() {
    var a Abser
    f := MyFloat(-math.Sqrt2)
    v := Vertex{3, 4}

    a = f  // a MyFloat 实现了 Abser
    a = &amp;v // a *Vertex 实现了 Abser

    // 下面一行，v 是一个 Vertex（而不是 *Vertex）
    // 所以没有实现 Abser。
    a = v

    fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f &lt; 0 {
        return float64(-f)
    }
    return float64(f)
}

type Vertex struct {
    X, Y float64
}

func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
</code></pre><h4 id=笔记>笔记</h4><pre><code>接口类型 是由一组方法签名定义的集合。

接口类型的变量可以保存任何实现了这些方法的值。

*注意：* 示例代码的 22 行存在一个错误。由于 Abs 方法只为 *Vertex （指针类型）定义，因此 Vertex（值类型）并未实现 Abser。
</code></pre><ol><li>本例中，申明了一个Abser的接口，要求实现一个Abs的方法，不带参数，返回值为float64</li><li><code>根据结构体Vertex的方法签名，参数值为v *Vertex,故v的类型应该也是*Vertex</code></li><li><code>方法1为39行修改为a=&v</code></li><li><code>方法2注释35，39行修改为a=v，32行修改为v := &Vertex{3, 4}</code></li><li>这个接口的申明可比PHP里面的复杂多了。</li><li>为什么要设计这么复杂的接口呢？来一点语法糖吧。</li></ol><p>声明不同类型的方法</p><table><thead><tr><th align=left>类型</th><th align=left>申明方法</th><th align=left>备注</th></tr></thead><tbody><tr><td align=left>结构体</td><td align=left><code>type Abser struct</code></td><td align=left>申明字段</td></tr><tr><td align=left>方法</td><td align=left><code>type MyFloat float64</code></td><td align=left></td></tr><tr><td align=left>接口</td><td align=left><code>type Abser interface</code></td><td align=left></td></tr></tbody></table><h4 id=interfaces-are-satisfied-implicitlygo>interfaces-are-satisfied-implicitly.go</h4><pre><code>package main

import &quot;fmt&quot;

type I interface {
    M()
}

type T struct {
    S string
}

// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。
func (t T) M() {
    fmt.Println(t.S)
}

func main() {
    var i I = T{&quot;hello&quot;}
    i.M()
}
</code></pre><h4 id=笔记-1>笔记</h4><pre><code>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。

隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。

因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。
</code></pre><ol><li>和其他语言不一样，实现接口不需要关键字implements，默认全部自动实现接口。</li><li>注意实例中i的类型为I，这个值得注意。</li><li>可以实现多个接口吗？</li></ol><h4 id=interface-valuesgo>interface-values.go</h4><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type I interface {
    M()
}

type T struct {
    S string
}

func (t *T) M() {
    fmt.Println(t.S)
}

type F float64

func (f F) M() {
    fmt.Println(f)
}

func main() {
    var i I

    i = &amp;T{&quot;Hello&quot;}
    describe(i)
    i.M()

    i = F(math.Pi)
    describe(i)
    i.M()
}

func describe(i I) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
</code></pre><h4 id=笔记-2>笔记</h4><pre><code>在内部，接口值可以看做包含值和具体类型的元组：

(value, type)
接口值保存了一个具体底层类型的具体值。

接口值调用方法时会执行其底层类型的同名方法。
</code></pre><ol><li>这里有点类似OOP的多态，根据参数类型不同调用对应的方法。</li><li><code>&T{"Hello"} -> t *T->T srtuct</code></li><li><code>F(math.Pi) -> f F-> F float64</code></li></ol><h3 id=interface-values-with-nilgo>interface-values-with-nil.go</h3><pre><code>package main

import &quot;fmt&quot;

type I interface {
    M()
}

type T struct {
    S string
}

func (t *T) M() {
    if t == nil {
        fmt.Println(&quot;&lt;nil&gt;&quot;)
        return
    }
    fmt.Println(t.S)
}

func main() {
    var i I

    var t *T
    i = t
    describe(i)
    i.M()

    i = &amp;T{&quot;hello&quot;}
    describe(i)
    i.M()
}

func describe(i I) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
</code></pre><h4 id=笔记-3>笔记</h4><pre><code>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。

在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。

*注意：* 保存了 nil 具体值的接口其自身并不为 nil。
</code></pre><ol><li>这个例子中申明了接口I，T的结构体</li><li>根据传递不同类型参数返回不同类型的值。</li><li>注意看不同接口的保存的值</li><li><code>(, *main.T)</code></li><li><code>(&{hello}, *main.T)</code></li></ol><h4 id=nil-interface-valuesgo>nil-interface-values.go</h4><pre><code>package main

import &quot;fmt&quot;

type I interface {
    M()
}

func main() {
    var i I
    describe(i)
    i.M()
}

func describe(i I) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
</code></pre><h4 id=笔记-4>笔记</h4><pre><code>nil 接口值既不保存值也不保存具体类型。
为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 **具体** 方法的类型。
1. 这里的nil值如何理解呢？
</code></pre><h4 id=empty-interafcego>empty-interafce.go</h4><pre><code>package main

import &quot;fmt&quot;

func main() {
    var i interface{}
    describe(i)

    i = 42
    describe(i)

    i = &quot;hello&quot;
    describe(i)
}

func describe(i interface{}) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}
</code></pre><h4 id=笔记-5>笔记</h4><pre><code>指定了零个方法的接口值被称为 *空接口：*

interface{}
空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）

空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。
</code></pre><ol><li>这里的空接口是否就是范型接口了？</li><li>传递任意数量参数的任意类型函数。</li></ol><h4 id=type-assertionsgo>type-assertions.go</h4><pre><code>package main

import &quot;fmt&quot;

func main() {
    var i interface{} = &quot;hello&quot;

    s := i.(string)
    fmt.Println(s)

    s, ok := i.(string)
    fmt.Println(s, ok)

    f, ok := i.(float64)
    fmt.Println(f, ok)

    f = i.(float64) // panic
    fmt.Println(f)
}
</code></pre><h4 id=笔记-6>笔记</h4><pre><code>类型断言 提供了访问接口值底层具体值的方式。

t := i.(T)
该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。

若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。
为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。

t, ok := i.(T)
若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。

否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。

请注意这种语法和读取一个映射时的相同之处。
</code></pre><ol><li>哪里来的恐慌？按照我的理解是抛出一个异常。</li><li>默认类型断言返回具体类型的值。如果没有保存特定的类型，那么会返回该类型的默认值。</li><li>结论是一定要判断返回的值和类型。</li></ol><h4 id=type-switchesgo>type-switches.go</h4><pre><code>package main

import &quot;fmt&quot;

func do(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf(&quot;Twice %v is %v\n&quot;, v, v*2)
    case string:
        fmt.Printf(&quot;%q is %v bytes long\n&quot;, v, len(v))
    default:
        fmt.Printf(&quot;I don't know about type %T!\n&quot;, v)
    }
}

func main() {
    do(21)
    do(&quot;hello&quot;)
    do(true)
}
</code></pre><h4 id=笔记-7>笔记</h4><pre><code>类型选择 是一种按顺序从几个类型断言中选择分支的结构。

类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。

switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。

此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。
</code></pre><h5 id=类型判断的方法>类型判断的方法</h5><table><thead><tr><th align=left>类型</th><th align=left>实现方法</th><th align=left>备注</th></tr></thead><tbody><tr><td align=left>–</td><td align=left><code>i.(type)</code></td><td align=left>获取类型</td></tr><tr><td align=left>string</td><td align=left><code>v,ok := i.(sring)</code></td><td align=left>获取字符串</td></tr><tr><td align=left>bool</td><td align=left><code>v,ok :=i.(bool)</code></td><td align=left>获取布尔值</td></tr><tr><td align=left>float64</td><td align=left><code>v,ok :=i.(float64)</code></td><td align=left>获取浮点数</td></tr><tr><td align=left>int</td><td align=left><code>v,ok :=i.(int)</code></td><td align=left>获取整型值</td></tr></tbody></table><h4 id=stringergo>stringer.go</h4><pre><code>package main

import &quot;fmt&quot;

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)
}

func main() {
    a := Person{&quot;Arthur Dent&quot;, 42}
    z := Person{&quot;Zaphod Beeblebrox&quot;, 9001}
    fmt.Println(a, z)
}
</code></pre><h4 id=笔记-8>笔记</h4><pre><code>fmt 包中定义的 Stringer 是最普遍的接口之一。

type Stringer interface {
    String() string
}
Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。
</code></pre><ol><li>这个例子，实现了一个stringer 的接口，必须有一个String()的方法</li><li>这里就类似于PHP的__toString()魔术方法了，一个类被当成字符串时的输出。</li></ol><h4 id=errorsgo>errors.go</h4><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

type MyError struct {
    When time.Time
    What string
}

func (e *MyError) Error() string {
    return fmt.Sprintf(&quot;at %v, %s&quot;,
        e.When, e.What)
}

func run() error {
    return &amp;MyError{
        time.Now(),
        &quot;it didn't work&quot;,
    }
}

func main() {
    if err := run(); err != nil {
        fmt.Println(err)
    }
}
</code></pre><h4 id=笔记-9>笔记</h4><pre><code>Go 程序使用 error 值来表示错误状态。

与 fmt.Stringer 类似，error 类型是一个内建接口：

type error interface {
    Error() string
}
（与 fmt.Stringer 类似，fmt 包在打印值时也会满足 error。）

通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil 来进行错误处理。

i, err := strconv.Atoi(&quot;42&quot;)
if err != nil {
    fmt.Printf(&quot;couldn't convert number: %v\n&quot;, err)
    return
}
fmt.Println(&quot;Converted integer:&quot;, i)
error 为 nil 时表示成功；非 nil 的 error 表示失败。
</code></pre><ol><li>申明了一个MyError的结构体</li><li>添加一个引用参数的函数Error()接口，run函数故意返回一个不是nil的值，输出Error的信息。</li></ol><h4 id=readergo>reader.go</h4><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;strings&quot;
)

func main() {
    r := strings.NewReader(&quot;Hello, Reader!&quot;)

    b := make([]byte, 8)
    for {
        n, err := r.Read(b)
        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)
        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])
        if err == io.EOF {
            break
        }
    }
}
</code></pre><h4 id=笔记-10>笔记</h4><pre><code>io 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。

Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。

io.Reader 接口有一个 Read 方法：

func (T) Read(b []byte) (n int, err error)
Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。

示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出。
</code></pre><ol><li>示例中初始化一个Rreader读取特定的字符串。</li><li>创建一个8个byte字节的数据，每次读取特定长度的字符串，遇到结尾的就break。</li></ol><h4 id=imagesgo>images.go</h4><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;image&quot;
)

func main() {
    m := image.NewRGBA(image.Rect(0, 0, 100, 100))
    fmt.Println(m.Bounds())
    fmt.Println(m.At(0, 0).RGBA())
}
</code></pre><h4 id=笔记-11>笔记</h4><pre><code>image 包定义了 Image 接口：

package image

type Image interface {
    ColorModel() color.Model
    Bounds() Rectangle
    At(x, y int) color.Color
}
*注意：* Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。

（请参阅文档了解全部信息。）

color.Color 和 color.Model 类型也是接口，但是通常因为直接使用预定义的实现 image.RGBA 和 image.RGBAModel 而被忽视了。这些接口和类型由 image/color 包定义。
</code></pre><ol><li>这几个例子都用到接口，接口才是学习go语言的必不可少的知识之一吧。</li><li>图像类的学习和使用</li></ol><h3 id=参考链接>参考链接</h3><ol><li><a href=https://tour.go-zh.org/methods/9>接口</a></li><li><a href=https://tour.go-zh.org/methods/10>接口与隐式实现</a></li><li><a href=https://tour.go-zh.org/methods/11>接口值</a></li><li><a href=https://tour.go-zh.org/methods/12>底层值为 nil 的接口值</a></li><li><a href=https://tour.go-zh.org/methods/13>nil 接口值</a></li><li><a href=https://tour.go-zh.org/methods/14>空接口</a></li><li><a href=https://tour.go-zh.org/methods/15>类型断言</a></li><li><a href=https://tour.go-zh.org/methods/16>类型选择</a></li></ol><p><img src=/wp-content/uploads/20181209.02.p1.png alt=img></p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/go/ rel=tag>Go</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%90%8E%E7%AB%AF/ rel=tag>后端</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="GeekWho avatar" src=/images/avatar.jpeg class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>关于 GeekWho</span></div><div class=authorbox__description>PHP and Go are the best language in the world.</div></div><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'13b47a49e0f947bf69e0',clientSecret:'a4f2f9622955ed3993f37d1b82eddab12abdeffe',repo:'xbc.me',owner:'geekwho11',admin:['geekwho11'],id:location.pathname,distractionFreeMode:false});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('gitalk-container').innerHTML='Gitalk comments not available by default when the website is previewed locally.';return;}
gitalk.render('gitalk-container');})();</script></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=搜索... name=q aria-label=搜索...></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://xbc.me></form></div><div class="widget-recent widget"><h4 class=widget__title>近期文章</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/hugo-deploy/>Hugo部署方案</a></li><li class=widget__item><a class=widget__link href=/add-gittalk-to-hugo/>为hugo添加gittalk组件</a></li><li class=widget__item><a class=widget__link href=/how-to-create-an-archives-page-with-hugo/>为hugo添加归档页面</a></li><li class=widget__item><a class=widget__link href=/hello-hugo-and-goodbye-wordpress/>你好Hugo，再见WordPress</a></li><li class=widget__item><a class=widget__link href=/build-master-slave-mysql-service/>搭建主从MySQL服务</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>分类</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/%E5%AD%A6%E7%BC%96%E7%A8%8B/>学编程</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%A5%9E%E7%A7%98%E6%9E%81%E5%AE%A2/>神秘极客</a></li><li class=widget__item><a class=widget__link href=/categories/%E9%9A%8F%E7%AC%94/>随笔</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>标签</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/githubpages/ title=GithubPages>GithubPages</a>
<a class="widget-taglist__link widget__link btn" href=/tags/go/ title=Go>Go</a>
<a class="widget-taglist__link widget__link btn" href=/tags/javascript/ title=JavaScript>JavaScript</a>
<a class="widget-taglist__link widget__link btn" href=/tags/linux/ title=Linux>Linux</a>
<a class="widget-taglist__link widget__link btn" href=/tags/magento/ title=Magento>Magento</a>
<a class="widget-taglist__link widget__link btn" href=/tags/mysql/ title=MySQL>MySQL</a>
<a class="widget-taglist__link widget__link btn" href=/tags/nginx/ title=Nginx>Nginx</a>
<a class="widget-taglist__link widget__link btn" href=/tags/php/ title=PHP>PHP</a>
<a class="widget-taglist__link widget__link btn" href=/tags/ubuntu/ title=Ubuntu>Ubuntu</a>
<a class="widget-taglist__link widget__link btn" href=/tags/unittest/ title=UnitTest>UnitTest</a>
<a class="widget-taglist__link widget__link btn" href=/tags/wordpress/ title=WordPress>WordPress</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%89%8D%E7%AB%AF/ title=前端>前端</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%90%8E%E7%AB%AF/ title=后端>后端</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/ title=常见算法>常见算法</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/ title=年终总结>年终总结</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=数据结构>数据结构</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">社交</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/geekwho11 target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:geekwho@xbc.me><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>geekwho@xbc.me</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2020 神秘极客.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a>主題</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>