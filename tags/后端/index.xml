<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>后端 on 神秘极客</title><link>/tags/%E5%90%8E%E7%AB%AF/</link><description>Recent content in 后端 on 神秘极客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 03 Feb 2019 03:17:50 +0000</lastBuildDate><atom:link href="/tags/%E5%90%8E%E7%AB%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>线程安全那些事</title><link>/thread-safety/</link><pubDate>Sun, 03 Feb 2019 03:17:50 +0000</pubDate><guid>/thread-safety/</guid><description>引言 在上一篇文章，我们了解了什么是进程/线程，把多进程和多线程进行了对比，那通常所说的线程安全是什么呢？要想搞清楚这个概念，那么我们可以尝试</description></item><item><title>进程那些事</title><link>/process-those-things/</link><pubDate>Sat, 02 Feb 2019 15:00:26 +0000</pubDate><guid>/process-those-things/</guid><description>什么是进程 在ARTS的微信群里，看到布置的命题作业，为了弄清楚一个概念，那所谓的进程到底是什么？ 作为程序员都知道，进程是一段程序代码，好像也</description></item><item><title>Tars实践</title><link>/tars/</link><pubDate>Wed, 23 Jan 2019 08:56:58 +0000</pubDate><guid>/tars/</guid><description>什么是Tars Tars这个名字取自于电影”星际穿越”中的机器人，它是基于名字服务使用Tars协议的高性能RPC开发框架，配套一体化的运营管理</description></item><item><title>并发-学习Go语言</title><link>/learn-go-goroutine/</link><pubDate>Mon, 07 Jan 2019 03:00:26 +0000</pubDate><guid>/learn-go-goroutine/</guid><description>阅读笔记 goroutines.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func say(s string) { for i := 0; i &amp;lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;quot;world&amp;quot;) say(&amp;quot;hello&amp;quot;) } 笔记 Go 程（goroutine）是由 Go 运行时管理的轻量级线程。 go f(x,</description></item><item><title>接口-学习Go语言</title><link>/learn-go-interface/</link><pubDate>Fri, 28 Dec 2018 03:00:50 +0000</pubDate><guid>/learn-go-interface/</guid><description>阅读笔记 interfaces.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat 实现了 Abser a = &amp;amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而</description></item><item><title>方法-学习Go语言</title><link>/learn-go-method/</link><pubDate>Fri, 21 Dec 2018 03:00:30 +0000</pubDate><guid>/learn-go-method/</guid><description>阅读笔记 methods.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 笔记 Go 没有类。不过你可以为结构体类型定义方法。 方法就是一类带</description></item><item><title>映射-学习Go语言</title><link>/learn-go-mapping/</link><pubDate>Fri, 14 Dec 2018 03:04:50 +0000</pubDate><guid>/learn-go-mapping/</guid><description>阅读笔记 maps.go package main import &amp;quot;fmt&amp;quot; type Vertex struct { Lat, Long float64 } var m map[string]Vertex func main() { m = make(map[string]Vertex) m[&amp;quot;Bell Labs&amp;quot;] = Vertex{ 40.68433, -74.39967, } fmt.Println(m[&amp;quot;Bell Labs&amp;quot;]) } 笔记 make 函数会返回给定类型的映射，并将其初始化备用。 m就是映射了，将k</description></item><item><title>切片-学习Go语言</title><link>/learn-go-slice/</link><pubDate>Fri, 07 Dec 2018 03:52:53 +0000</pubDate><guid>/learn-go-slice/</guid><description>阅读笔记 slices.go package main import &amp;quot;fmt&amp;quot; func main() { primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) } 笔记 切片的内部实现，类似一个链表+头尾指针。 数组的切片范围为low&amp;lt;= x &amp;lt; high slices-pointers.go package</description></item><item><title>结构体-学习Go语言</title><link>/learn-go-structrue/</link><pubDate>Tue, 27 Nov 2018 03:39:35 +0000</pubDate><guid>/learn-go-structrue/</guid><description>阅读笔记 pointers.go package main import &amp;quot;fmt&amp;quot; func main() { i, j := 42, 2701 p := &amp;amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = &amp;amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the</description></item><item><title>控制流程-学习Go语言</title><link>/learn-go-flow/</link><pubDate>Tue, 20 Nov 2018 03:27:17 +0000</pubDate><guid>/learn-go-flow/</guid><description>阅读笔记 if-with-a-short-statement.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v &amp;lt; lim { return v } return lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } 笔记 同 for 一样， if 语句可以在条件表达式前执行一个简</description></item><item><title>函数值-学习Go语言</title><link>/learn-go-function/</link><pubDate>Tue, 13 Nov 2018 03:16:15 +0000</pubDate><guid>/learn-go-function/</guid><description>阅读笔记 functions-values.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) } 笔记 函数也是值。它们可以像其它值一样传递。 函数值可以用</description></item><item><title>消息队列的思考</title><link>/message-system/</link><pubDate>Tue, 06 Nov 2018 03:00:27 +0000</pubDate><guid>/message-system/</guid><description>什么是消息队列 维基百科的定义：在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软</description></item><item><title>MaxWell的学习</title><link>/learn-maxwell/</link><pubDate>Sat, 27 Oct 2018 03:00:32 +0000</pubDate><guid>/learn-maxwell/</guid><description>什么是MaxWell？ MaxWell守护进程是读取MySQL的二进制日志，将更新操作写入到消息队列，例如Kafka，RabbitMQ，Red</description></item><item><title>配置系统的思考</title><link>/config-system/</link><pubDate>Sat, 20 Oct 2018 03:00:00 +0000</pubDate><guid>/config-system/</guid><description>配置系统在整个软件的生命周期里，有着很重要的角色。例如： 在新公司上班，第一天需要配置开发环境。。。 多环境部署，开发、测试、预发布、生产不同环</description></item><item><title>堆排序</title><link>/learn-algorithm-heap-sort/</link><pubDate>Sat, 13 Oct 2018 03:00:00 +0000</pubDate><guid>/learn-algorithm-heap-sort/</guid><description>具体实现 见GitHub版本库的堆排序。 算法实现 实现 该算法按照二叉树的原理。 完全二叉树：深度为k，有n个节点的二叉树，当且仅当其每一个节点都与</description></item><item><title>归并排序</title><link>/learn-algorithm-merge-sort/</link><pubDate>Sat, 06 Oct 2018 03:00:00 +0000</pubDate><guid>/learn-algorithm-merge-sort/</guid><description>具体实现 见GitHub版本库的归并排序。 算法实现 采用2层循环遍历，实现两个已排序的数组合并为一个排序数组。 第一层循环，从一个元素开始到最后一</description></item><item><title>选择排序</title><link>/learn-algorithm-select-sort/</link><pubDate>Thu, 27 Sep 2018 03:00:00 +0000</pubDate><guid>/learn-algorithm-select-sort/</guid><description>具体实现 见GitHub版本库的选择排序。 算法实现 采用2层循环遍历实现。 第一层循环，从一个元素开始到最后一个元素为止。 选择每次循环的第一个元素</description></item><item><title>快速排序</title><link>/learn-algorithm-quick-sort/</link><pubDate>Thu, 20 Sep 2018 03:00:51 +0000</pubDate><guid>/learn-algorithm-quick-sort/</guid><description>具体实现 见GitHub版本库的选择排序。 算法实现 采用2层循环遍历实现。 第一层循环，从一个元素开始到最后一个元素为止。 选择每次循环的第一个元素</description></item><item><title>冒泡排序</title><link>/learn-algorithm-bubble-sort/</link><pubDate>Fri, 14 Sep 2018 03:00:54 +0000</pubDate><guid>/learn-algorithm-bubble-sort/</guid><description>具体实现 见GitHub版本库的冒泡排序。 算法实现 根据需要排序的个数，进行倒序循环，起点为待排序个数，依次递减，直到1为止。 第二层循环，从第一</description></item><item><title>字符串反转</title><link>/learn-algorithm-string-reverse/</link><pubDate>Fri, 07 Sep 2018 03:00:56 +0000</pubDate><guid>/learn-algorithm-string-reverse/</guid><description>具体实现 见GitHub版本库的字符串反转。 PHP内置 只支持ASCII字符串 正则实现 /* 其中正则的两个修正符的说明如下： u (PCRE_UTF8) 此修正符启用了一个 PCRE</description></item><item><title>二分法查找-算法学习</title><link>/learn-algorithm-binary-search/</link><pubDate>Tue, 28 Aug 2018 03:00:46 +0000</pubDate><guid>/learn-algorithm-binary-search/</guid><description>二分搜索算法 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）[1]、</description></item><item><title>搭建Docker开发环境-学习Go语言</title><link>/leanr-go-docker/</link><pubDate>Tue, 21 Aug 2018 03:00:28 +0000</pubDate><guid>/leanr-go-docker/</guid><description>前言 学习Go语言之前，尝试搭建基于Docker的开发环境。 基础环境 根据之前的经验，实现一个Docker的虚拟机环境。 可以在Ubuntu 18.</description></item><item><title>Gin和grpc搭建-学习Go语言</title><link>/learn-go-gin/</link><pubDate>Tue, 14 Aug 2018 03:00:54 +0000</pubDate><guid>/learn-go-gin/</guid><description>安装grpc 如果你遇到这样的错误 package google.golang.org/grpc: unrecognized import path &amp;quot;google.golang.org/grpc&amp;quot;(https fetch: Get https://google.golang.org/grpc?go-get=1: dial tcp 216.239.37.1:443: i/o timeout) 解决方案，采用最新github的地址。 git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text go get -u github.com/golang/protobuf/{proto,protoc-gen-go} git clone https://github.com/google/go-genproto.git $GOPATH/src/google.golang.org/genproto cd</description></item><item><title>单元测试-学习Go语言</title><link>/learn-go-unitest/</link><pubDate>Tue, 07 Aug 2018 03:00:07 +0000</pubDate><guid>/learn-go-unitest/</guid><description>实现 采用自身的testing包实现。 踩坑 单元测试和源文件必要放在同一个目录下，才可以正常执行。 Go PHPUnit *_test文件和源文件一起 必须 任意 断言 第</description></item><item><title>基础-学习Go语言</title><link>/learn-go-basic/</link><pubDate>Sat, 28 Jul 2018 03:00:37 +0000</pubDate><guid>/learn-go-basic/</guid><description>包 每个 Go 程序都是由包构成的。 程序从 main 包开始运行。 本程序通过导入路径 “fmt” 和 “math/rand” 来使用这两个包。 按照约定，包名与导入路径</description></item><item><title>安装Redmine 2.0</title><link>/install-redmine-2-0/</link><pubDate>Wed, 16 May 2012 09:00:00 +0000</pubDate><guid>/install-redmine-2-0/</guid><description>Redmine 这厮就这样大张旗鼓的升级到了2.0。正好公司的mantisbt实在是不给力，就准备安装Redmine。很之前安装的方法并没有什么区别，可以</description></item><item><title>添加Apache模块</title><link>/apache-add-module/</link><pubDate>Sat, 12 May 2012 10:00:00 +0000</pubDate><guid>/apache-add-module/</guid><description>和php添加模块类似，Apache也有动态添加模块的工具apxs。 找到下载的模块目录 cd /usr/local/apache/modules/filters // 编译并安装 apxs -ica mod_deflate.c //会出现编译问题，换成绝对路径编</description></item><item><title>动态添加php extension</title><link>/add-php-extension/</link><pubDate>Sat, 12 May 2012 09:30:00 +0000</pubDate><guid>/add-php-extension/</guid><description>通常情况下，在手动编译下都会添加一些常用的php模块，例如mbstring、curl等。那如果手动编译后，发现有些应用又需要添加新的php模</description></item><item><title>利用vsftpd搭建ftp服务器</title><link>/configure-vsftpd-server/</link><pubDate>Fri, 02 Mar 2012 01:00:24 +0000</pubDate><guid>/configure-vsftpd-server/</guid><description>起因是帮朋友弄一个网站，服务器是最小化安装，并没有安装任何其他的cpanel软件，要实现的需求是建立一个用户chroot到一个特殊的目录。 安</description></item><item><title>CentOS 6 安装Redmine</title><link>/centos-install-redmine/</link><pubDate>Sat, 25 Feb 2012 09:00:00 +0000</pubDate><guid>/centos-install-redmine/</guid><description>Redmine是一个灵活的项目管理web应用，采用Ruby on Rails框架开发。Redmine是典型的web 2.0网站，项目管理系统的后起之</description></item><item><title>快速配置LNMP环境Nginx0.8.54+MYSQL5.5.16+PHP5.3.8+CentOS 6</title><link>/quickly-configure-lnmp-environment-nginx0-8-54-mysql5-5-16-php5-3-8-centos-6/</link><pubDate>Sat, 05 Nov 2011 09:30:00 +0000</pubDate><guid>/quickly-configure-lnmp-environment-nginx0-8-54-mysql5-5-16-php5-3-8-centos-6/</guid><description>最近购买了Linode的VPS服务，就开始着手以Nginx 为基础搭建LNMP平台，体验Nginx的魅力。Linux OS选择的是Linode的CentOS 6，话说CentOS 6出来太慢了。。。</description></item><item><title>迁移SVN 到Git Server</title><link>/svn-to-git-server/</link><pubDate>Sat, 15 Oct 2011 08:25:00 +0000</pubDate><guid>/svn-to-git-server/</guid><description>由于先前是用SVN做代码的版本管理，现在需要尝试将SVN转到Git来，由于Git自身附带了高质量的转换工具，剩下我们就需要做好迁移的配置。Git自带的桥接命令git svn 可以与svn交互，这样并不完美，不如一次性把它做好，特此记录下迁移的过程。</description></item><item><title>Redmine升级</title><link>/redmine-upgrade/</link><pubDate>Mon, 04 Jul 2011 12:00:00 +0000</pubDate><guid>/redmine-upgrade/</guid><description>上篇文章介绍如何安装Redmine，运行一段时间，发现Redmine都已经发布1.2版本，跟chrome有得一拼了。好了，本文记录将redmine从1.0.4升级到1.1.3的过程。按照官方的最新文档升级RedmineUpgrade，稍有修改。</description></item><item><title>Nginx 平滑升级</title><link>/nginx-upgrade/</link><pubDate>Sat, 25 Jun 2011 12:00:00 +0000</pubDate><guid>/nginx-upgrade/</guid><description>Nginx(&amp;ldquo;engine x&amp;rdquo;) 是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器 。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的Rambler.ru 站点开发的，它已经在该站点运行超过四年多了。Igor 将源代码以类BSD许可证的形式发布。自Nginx 发布四年来，Nginx 已经因为它的稳定性、丰富的功能集、 示例配置文件和低系统资源的消耗而闻名了。</description></item><item><title>Red Hat 安装配置Yum</title><link>/install-yum-on-red-hat/</link><pubDate>Sat, 18 Jun 2011 12:00:00 +0000</pubDate><guid>/install-yum-on-red-hat/</guid><description>在公司接手一台服务器，准备做点想做的事，发现竟然连vim都没有，没事，我自己装，悲剧的发现连Yum都没装&amp;hellip;</description></item><item><title>在windows安装配置Git开发环境</title><link>/install-git-on-windows/</link><pubDate>Sun, 08 May 2011 11:00:00 +0000</pubDate><guid>/install-git-on-windows/</guid><description>记录Git的安装过程，实际起来很简单。</description></item><item><title>在Ubuntu 上配置Git Server</title><link>/install-git-on-ubuntu/</link><pubDate>Mon, 02 May 2011 02:00:00 +0000</pubDate><guid>/install-git-on-ubuntu/</guid><description>记录Git的安装过程，实际起来很简单。</description></item><item><title>Y460在Windows 7下安装CentOS-5.5</title><link>/installing-centos-in-lenovo-y460/</link><pubDate>Fri, 07 Jan 2011 01:00:16 +0000</pubDate><guid>/installing-centos-in-lenovo-y460/</guid><description>最近看了 鸟哥的Linux私房菜，这本书很适合新手学习，元旦放假没事，就学习一下CentOS系统的安装。安装环境是Windows 7 旗舰版+Y460,具体的笔记本配置请看这里。</description></item><item><title>学习vim</title><link>/learning-vim/</link><pubDate>Thu, 11 Nov 2010 15:10:30 +0000</pubDate><guid>/learning-vim/</guid><description>因为在工作中不可避免用用到linux主机，要操作终端，但是我对vi编辑器一筹莫展，总是看黑糊糊的框框感到很无奈，功力不够啊，想在终端操作文本，还是有困难，觉得需要认真学习下vi编辑器的操作。</description></item><item><title>php的AOP编程实例</title><link>/php-programming-examples-of-aop/</link><pubDate>Sun, 07 Nov 2010 11:29:09 +0000</pubDate><guid>/php-programming-examples-of-aop/</guid><description>最近研究下php下面的AOP实现，在网上也看到不少的文章，老王在他的手册里利用魔术方法实现准AOP 这个方法很好。</description></item><item><title>php开发环境搭建</title><link>/php-development-environment-to-build/</link><pubDate>Sun, 07 Mar 2010 11:32:24 +0000</pubDate><guid>/php-development-environment-to-build/</guid><description>本文介绍如何搭建PHP开发环境。</description></item></channel></rss>